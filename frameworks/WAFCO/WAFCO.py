import json, re

import constants as _C
from utils.Config import Config
from utils.Tools import _warn, _info
from frameworks.Framework import Framework
from frameworks.helper.WATools import WATools
import pprint

pillars = ["operationalExcellence","security","reliability","performanceEfficiency","costOptimization","sustainability"]

class WAFCO(Framework):
    WATools = None
    ResultCache = {}
    isBeta = False
    def __init__(self, data):
        super().__init__(data)
        self.isBeta = Config.get('beta', False)

        self.WATools = None
        # for pillar in pillars:
        #     waTools = WATools(pillar)
        waTools = WATools('costOptimization')
        cliParams = Config.get('_SS_PARAMS')

        tmpParams = {}
        self.ResultCache = {}
        if 'others' in cliParams and not cliParams['others'] == None:
            params = cliParams['others']
            cfg = json.loads(params)

            if 'WA' in cfg:
                tmpParams = cfg['WA']

        if waTools.preCheck(tmpParams): 
            self.WATools = waTools
            self.WATools.init(tmpParams)
            self.WATools.createReportIfNotExists()
            self.WATools.listAnswers()
            # print(self.WATools.answerSets)
        

    def _hookPostItemActivity(self, title, section, checks, comp):
        if self.WATools == None or self.WATools.HASPERMISSION == False:
            return title, section, checks, comp
        
        titleNum = self.extractNumber(title)
        # pprint.pprint(titleNum)
        sectNum = self.extractNumber(section)
        # pprint.pprint(sectNum)
        paired = "{}::{}".format(titleNum, sectNum)
        # pprint.pprint(paired)
        newChecks = "<h4>{}</h4>{}".format(self.getDescription(titleNum, paired), checks)

        titleKey = self.WATools.answerSets.get(titleNum, [None])[0]
        if not titleKey in self.ResultCache:
            self.ResultCache[titleKey] = {
                "0": [],
                "1": [],
                "-1": []
            }

        # safer way to always record a choice
        choice_id, choice_desc = self.WATools.answerSets.get(paired, [None, None])

        if comp == 1:
            # positive → pick the actual choiceId
            if choice_id:
                self.ResultCache[titleKey]["1"].append(choice_id)
            else:
                self.ResultCache[titleKey]["0"].append("none")  # fallback neutral
        elif comp == -1:
            # negative → still pick choiceId (not desc!)
            if choice_id:
                self.ResultCache[titleKey]["-1"].append(choice_id)
            else:
                self.ResultCache[titleKey]["0"].append("none")
        else:
            # default / neutral → explicitly mark
            self.ResultCache[titleKey]["0"].append(choice_id or "none")

            
        return title, section, newChecks, comp
        
    def _hookPostItemsLoop(self):
        if self.WATools is None or not self.WATools.HASPERMISSION:
            return

        for questionId, opts in self.ResultCache.items():
            selected_choices = opts.get("1", [])

            # Build notes from failed items
            failed_items = opts.get("-1", [])
            failed_notes = "\n- ".join(failed_items) if failed_items else "None"

            if not selected_choices:  # Nothing selected
                unselectedNotes = (
                    f"***Generated by SS\n\nNo security controls selected.\n"
                    f"Here are the items failed SS checks:\n- {failed_notes}"
                )
            else:
                unselectedNotes = (
                    f"***Generated by SS\n\nHere are the items failed SS checks:\n- {failed_notes}"
                )

            # print(f"[WAFCO] Updating QuestionId: {questionId} with Choices: {selected_choices}")
            # print(f"[WAFCO] Failed notes: {failed_notes}")

            try:
                self.WATools.updateAnswers(questionId, selected_choices, unselectedNotes)
            except Exception as e:
                _warn(f"[WAFCO] Failed to update answers for QuestionId {questionId}: {e}")

        pass

    def extractNumber(self, s):
        match = re.search(r'\d+', s)
        return match.group() if match else None
    
    def getDescription(self, titleNum, paired):
        titleStr = self.WATools.answerSets.get(titleNum, [None])[1]
        sectStr = self.WATools.answerSets.get(paired, [None])[1]
        return f"{titleStr} - {sectStr}"

    def _hookPostBuildContentDetail(self):
        self.WATools.createMilestoneIfNotExists()